<input type="hidden" id="uiJsName" value="pageDevice">

<div class="tit-wrap">
	<h1 class="typo-headline-l">Device</h1>
</div>

<section class="sec-wrap">
	<h2 class="typo-headline-m">Device Display Summary</h2>
	<div>
		<div class="dv-phone"></div>
		<div class="dv-fphone"></div>
		<div class="dv-tablet"></div>
		<div class="dv-laptop"></div>
		<div class="dv-desktop"></div>
	</div>
</section>

<section class="sec-wrap">
	<h2 class="typo-headline-m">Browser Breakpoint</h2>
	<p>최적의 환경을 구성하기 위해 breakpoint를 디바이스의 해상도에 따라 12가지로 나눈다. 그중에 600을 기준으로 4, 8 열로 960기준으로 8, 12열로 나누어진다.</p>
	<ul class="bul-hyphen">
		<li>04 columns : ~ 599</li>
		<li>08 columns : 600 ~ 904</li>
		<li>12 columns : 960 ~</li>
		
		
	</ul>
	<div class="tbl-base type-card">
		<table>
			<caption>breakpoint</caption>
			<thead>
				<tr>
					<th scope="col">
						Breakpoint Range (dp)
					</th>
					<th scope="col">
						Portrait
					</th>
					<th scope="col">
						Landscape
					</th>
					<th scope="col">
						Window
					</th>
					<th scope="col">
						Columns
					</th>
					<th scope="col">
						Margins / Gutters*
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td colspan="1" rowspan="1">
						0 – 359
					</td>
					<td colspan="1" rowspan="1">
						small handset
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						xsmall
					</td>
					<td colspan="1" rowspan="1">
						4
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						360 – 399
					</td>
					<td colspan="1" rowspan="1">
						medium handset
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						xsmall
					</td>
					<td colspan="1" rowspan="1">
						4
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						400 – 479
					</td>
					<td colspan="1" rowspan="1">
						large handset
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						xsmall
					</td>
					<td colspan="1" rowspan="1">
						4
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						480 – 599
					</td>
					<td colspan="1" rowspan="1">
						large handset
					</td>
					<td colspan="1" rowspan="1">
						small handset
					</td>
					<td colspan="1" rowspan="1">
						xsmall
					</td>
					<td colspan="1" rowspan="1">
						4
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
			</tbody>
			<tbody class="tbl-tbody">
				<tr>
					<td colspan="1" rowspan="1">
						600 – 719
					</td>
					<td colspan="1" rowspan="1">
						small tablet
					</td>
					<td colspan="1" rowspan="1">
						medium handset
					</td>
					<td colspan="1" rowspan="1">
						small
					</td>
					<td colspan="1" rowspan="1">
						8
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						720 – 839
					</td>
					<td colspan="1" rowspan="1">
						large tablet
					</td>
					<td colspan="1" rowspan="1">
						large handset
					</td>
					<td colspan="1" rowspan="1">
						small
					</td>
					<td colspan="1" rowspan="1">
						8
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						840 – 959
					</td>
					<td colspan="1" rowspan="1">
						large tablet
					</td>
					<td colspan="1" rowspan="1">
						large handset
					</td>
					<td colspan="1" rowspan="1">
						small
					</td>
					<td colspan="1" rowspan="1">
						8
					</td>
					<td colspan="1" rowspan="1">
						16
					</td>
				</tr>
			</tbody>
			<tbody class="tbl-tbody">
				<tr>
					<td colspan="1" rowspan="1">
						960 – 1023
					</td>
					<td colspan="1" rowspan="1">
						large tablet
					</td>
					<td colspan="1" rowspan="1">
						small tablet
					</td>
					<td colspan="1" rowspan="1">
						small
					</td>
					<td colspan="1" rowspan="1">
						12
					</td>
					<td colspan="1" rowspan="1">
						24
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						1024 – 1279
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						large tablet
					</td>
					<td colspan="1" rowspan="1">
						medium
					</td>
					<td colspan="1" rowspan="1">
						12
					</td>
					<td colspan="1" rowspan="1">
						24
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						1280 – 1439
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						large tablet
					</td>
					<td colspan="1" rowspan="1">
						medium
					</td>
					<td colspan="1" rowspan="1">
						12
					</td>
					<td colspan="1" rowspan="1">
						24
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						1440 – 1599
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						large
					</td>
					<td colspan="1" rowspan="1">
						12
					</td>
					<td colspan="1" rowspan="1">
						24
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						1600 – 1919
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						large
					</td>
					<td colspan="1" rowspan="1">
						12
					</td>
					<td colspan="1" rowspan="1">
						24
					</td>
				</tr>
				<tr>
					<td colspan="1" rowspan="1">
						1920 +
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
					</td>
					<td colspan="1" rowspan="1">
						xlarge
					</td>
					<td colspan="1" rowspan="1">
						12
					</td>
					<td colspan="1" rowspan="1">
						24
					</td>
				</tr>
			</tbody>
		</table>
	</div>
</section>

<script>
	// --- table sorting
	/*!
	 * tablesort v5.0.2 (2017-11-12)
	 * http://tristen.ca/tablesort/demo/
	 * Copyright (c) 2017 ; Licensed MIT
	 */
	;
	(function () {
		function Tablesort(el, options) {
			if (!(this instanceof Tablesort)) return new Tablesort(el, options);

			if (!el || el.tagName !== 'TABLE') {
				throw new Error('Element must be a table');
			}
			this.init(el, options || {});
		}

		var sortOptions = [];

		var createEvent = function (name) {
			var evt;

			if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {
				evt = document.createEvent('CustomEvent');
				evt.initCustomEvent(name, false, false, undefined);
			} else {
				evt = new CustomEvent(name);
			}

			return evt;
		};

		var getInnerText = function (el) {
			return el.getAttribute('data-sort') || el.textContent || el.innerText || '';
		};

		// Default sort method if no better sort method is found
		var caseInsensitiveSort = function (a, b) {
			a = a.trim().toLowerCase();
			b = b.trim().toLowerCase();

			if (a === b) return 0;
			if (a < b) return 1;

			return -1;
		};

		// Stable sort function
		// If two elements are equal under the original sort function,
		// then there relative order is reversed
		var stabilize = function (sort, antiStabilize) {
			return function (a, b) {
				var unstableResult = sort(a.td, b.td);

				if (unstableResult === 0) {
					if (antiStabilize) return b.index - a.index;
					return a.index - b.index;
				}

				return unstableResult;
			};
		};

		Tablesort.extend = function (name, pattern, sort) {
			if (typeof pattern !== 'function' || typeof sort !== 'function') {
				throw new Error('Pattern and sort must be a function');
			}

			sortOptions.push({
				name: name,
				pattern: pattern,
				sort: sort
			});
		};

		Tablesort.prototype = {

			init: function (el, options) {
				var that = this,
					firstRow,
					defaultSort,
					i,
					cell;

				that.table = el;
				that.thead = false;
				that.options = options;

				if (el.rows && el.rows.length > 0) {
					if (el.tHead && el.tHead.rows.length > 0) {
						for (i = 0; i < el.tHead.rows.length; i++) {
							if (el.tHead.rows[i].getAttribute('data-sort-method') === 'thead') {
								firstRow = el.tHead.rows[i];
								break;
							}
						}
						if (!firstRow) {
							firstRow = el.tHead.rows[el.tHead.rows.length - 1];
						}
						that.thead = true;
					} else {
						firstRow = el.rows[0];
					}
				}

				if (!firstRow) return;

				var onClick = function () {
					if (that.current && that.current !== this) {
						that.current.removeAttribute('aria-sort');
					}

					that.current = this;
					that.sortTable(this);
				};

				// Assume first row is the header and attach a click handler to each.
				for (i = 0; i < firstRow.cells.length; i++) {
					cell = firstRow.cells[i];
					cell.setAttribute('role', 'columnheader');
					if (cell.getAttribute('data-sort-method') !== 'none') {
						cell.tabindex = 0;
						cell.addEventListener('click', onClick, false);

						if (cell.getAttribute('data-sort-default') !== null) {
							defaultSort = cell;
						}
					}
				}

				if (defaultSort) {
					that.current = defaultSort;
					that.sortTable(defaultSort);
				}
			},

			sortTable: function (header, update) {
				var that = this,
					column = header.cellIndex,
					sortFunction = caseInsensitiveSort,
					item = '',
					items = [],
					i = that.thead ? 0 : 1,
					sortMethod = header.getAttribute('data-sort-method'),
					sortOrder = header.getAttribute('aria-sort');

				that.table.dispatchEvent(createEvent('beforeSort'));

				// If updating an existing sort, direction should remain unchanged.
				if (!update) {
					if (sortOrder === 'ascending') {
						sortOrder = 'descending';
					} else if (sortOrder === 'descending') {
						sortOrder = 'ascending';
					} else {
						sortOrder = that.options.descending ? 'descending' : 'ascending';
					}

					header.setAttribute('aria-sort', sortOrder);
				}

				if (that.table.rows.length < 2) return;

				// If we force a sort method, it is not necessary to check rows
				if (!sortMethod) {
					while (items.length < 3 && i < that.table.tBodies[0].rows.length) {
						item = getInnerText(that.table.tBodies[0].rows[i].cells[column]);
						item = item.trim();

						if (item.length > 0) {
							items.push(item);
						}

						i++;
					}

					if (!items) return;
				}

				for (i = 0; i < sortOptions.length; i++) {
					item = sortOptions[i];

					if (sortMethod) {
						if (item.name === sortMethod) {
							sortFunction = item.sort;
							break;
						}
					} else if (items.every(item.pattern)) {
						sortFunction = item.sort;
						break;
					}
				}

				that.col = column;

				for (i = 0; i < that.table.tBodies.length; i++) {
					var newRows = [],
						noSorts = {},
						j,
						totalRows = 0,
						noSortsSoFar = 0;

					if (that.table.tBodies[i].rows.length < 2) continue;

					for (j = 0; j < that.table.tBodies[i].rows.length; j++) {
						item = that.table.tBodies[i].rows[j];
						if (item.getAttribute('data-sort-method') === 'none') {
							// keep no-sorts in separate list to be able to insert
							// them back at their original position later
							noSorts[totalRows] = item;
						} else {
							// Save the index for stable sorting
							newRows.push({
								tr: item,
								td: getInnerText(item.cells[that.col]),
								index: totalRows
							});
						}
						totalRows++;
					}
					// Before we append should we reverse the new array or not?
					// If we reverse, the sort needs to be `anti-stable` so that
					// the double negatives cancel out
					if (sortOrder === 'descending') {
						newRows.sort(stabilize(sortFunction, true));
					} else {
						newRows.sort(stabilize(sortFunction, false));
						newRows.reverse();
					}

					// append rows that already exist rather than creating new ones
					for (j = 0; j < totalRows; j++) {
						if (noSorts[j]) {
							// We have a no-sort row for this position, insert it here.
							item = noSorts[j];
							noSortsSoFar++;
						} else {
							item = newRows[j - noSortsSoFar].tr;
						}

						// appendChild(x) moves x if already present somewhere else in the DOM
						that.table.tBodies[i].appendChild(item);
					}
				}

				that.table.dispatchEvent(createEvent('afterSort'));
			},

			refresh: function () {
				if (this.current !== undefined) {
					this.sortTable(this.current, true);
				}
			}
		};

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = Tablesort;
		} else {
			window.Tablesort = Tablesort;
		}
	})();

	// --- table sorting by number
	(function () {
		var cleanNumber = function (i) {
				return i.replace(/[^\-?0-9.]/g, '');
			},

			compareNumber = function (a, b) {
				a = parseFloat(a);
				b = parseFloat(b);

				a = isNaN(a) ? 0 : a;
				b = isNaN(b) ? 0 : b;

				return a - b;
			};

		Tablesort.extend('number', function (item) {
			return item.match(/^[-+]?[£\x24Û¢´€]?\d+\s*([,\.]\d{0,2})/) || // Prefixed currency
				item.match(/^[-+]?\d+\s*([,\.]\d{0,2})?[£\x24Û¢´€]/) || // Suffixed currency
				item.match(/^[-+]?(\d)*-?([,\.]){0,1}-?(\d)+([E,e][\-+][\d]+)?%?$/); // Number
		}, function (a, b) {
			a = cleanNumber(a);
			b = cleanNumber(b);

			return compareNumber(b, a);
		});
	}());


	// ---  Tris de tableau
	var sorts = document.querySelectorAll('.tablesort');
	for (var index = 0; index < sorts.length; index++) {
		var sort = sorts[index];
		new Tablesort(sort);
	}
</script>